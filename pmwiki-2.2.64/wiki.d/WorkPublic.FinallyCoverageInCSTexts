version=pmwiki-2.1.27 ordered=1 urlencoded=1
agent=Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.1.3) Gecko/20090909 Fedora/3.5.3-1.fc11 Firefox/3.5.3
author=
csum=
ctime=1256589732
host=148.61.162.209
name=WorkPublic.FinallyCoverageInCSTexts
rev=48
targets=
text=This is kind of embarrassing; but, although I've programmed in Java since 1996 and have taught it since 2004, I just figured out what @@finally@@ blocks are ''really'' for.  When the light bulb finally came on, I went and looked back through several CS 1 and CS 2 texts to see what I missed.  In my opinion, the explanations and examples in these texts are misleading (albeit unintentionally).%0a%0a%0aConsider the two blocks of code below.  From the perspective of a typical CS 1 or CS 2 student, these two code blocks will always have identical behavior. (Note:  The code below is my example, it doesn't represent any book's example.  Those come later.)%0a%0a||!Example 1 ||!Example 2 ||%0a||[@public class Example 1%0a{%0a   public static int finally1(String data)%0a   {%0a     if (data == null) {%0a        return 0;%0a     }%0a     int answer;%0a     try {%0a        answer = Integer.parseInt(data);%0a     } catch (NumberFormatException nfe) {%0a        answer = -1;%0a        err.println(data + %0a                    " is not an integer!");%0a     } finally {%0a        System.out.println("Hi, Mom!");%0a     }%0a     return answer; %0a}%0a@]||[@public class Example 2 %0a{%0a   public static int finallyTest1(String data)%0a   {%0a     if (data == null) {%0a        return 0;%0a     }%0a     int answer;%0a     try {%0a        answer = Integer.parseInt(data);%0a     } catch (NumberFormatException nfe) {%0a        answer = -1;%0a        err.println(data + %0a                    " is not an integer!");%0a     } %0a     %0a     System.out.println("Hi, Mom!");%0a     return answer; %0a   }%0a}%0a@]||%0a%0aThe circumstances under which the two examples will behave differently are limited to extreme, rare, or advanced situations such as an @@OutOfMemory@@ error or some sort of timer or thread-based interrupt.   Such situations are rare in CS 1 and CS 2.%0a%0aReplacing a @@finally@@ block with a block of code immediately following the @@catch@@ statements only affects the behavior of the code if there is an exit point in one of the @@try@@ or @@catch@@ blocks.  In most textbooks, it is not clear from the example code that such an exit point exists because the @@try@@ and @@catch@@ blocks don't contain any @@return@@, @@break@@, or @@throw@@ statements, and the @@catch@@ blocks appear to catch all possible exceptions (at least from the perspective of a typical CS 1 or CS 2 student).%0a%0aThis is precisely why it took me 13 years to figure out what the @@finally@@ block really did:  I had never seen a code example in which it was clear that the method could end without running the code immediately following the last @@catch@@ block.%0a%0aConsider the following example from Malik's texts:%0a%0a[@%0atry%0a{%0a   // statements%0a}%0acatch (ExceptionClassName1 objRef1)%0a{%0a   // exception handler code%0a}%0acatch (ExceptionClassName2 objRef2)%0a{%0a  // exception handler code%0a}%0a.%0a.%0a.%0acatch (ExceptionClassNameN objRefN)%0a{%0a   // exception handler code%0a}%0afinally%0a{%0a   // statements%0a}%0a@]%0a%0aThe fact that the bodies of the blocks are comments implies that the details aren't important.  However, the details are ciritical to the complete understanding of @@finally@@:  If the bodies of these blocks don't have a @@return@@, @@break@@, or @@throws@@ clause, or if no statement in the @@try@@ block throws an uncaught exception, the presence of the @@finally@@ keyword does not affect the behavior of this code.%0a%0aThe text accompanying the code above does not clarify this point:%0a%0a->"The last @@catch@@ block may or may not be followed by a @@finally@@ block.  Any code contained in a @@finally@@ block always executes, regardless of whether an exception occurs, except when the program exits early from a @@try@@ block by calling the method @@System.exit@@.  If a @@try@@ block has no @@catch@@ block, then it ''must'' have a @@finally@@ block. ... If there is a @@finally@@ block after the last @@catch@@ block, the @@finally@@ block executes regardless of whether an exception occurs."%0a%0aOut of curiosity, I went back through my collection of Java textbooks and categorized both the written explanation of the @@finally@@ keyword and the corresponding sample code.  The remainder of this document contains the results.%0a%0aAvoiding misunderstandings like mine is eays:  Authors should be sure to clearly explain that @@finally@@ blocks are used to guarantee that code gets run even if %0a%0a*a @@try@@ block throws an ''unhandled'' exception%0a*a @@try@@ or @@catch@@ block contains a @@return@@ statement%0a%0aThey could further improve the situation by %0a%0a* including sample code that clearly exhibits one of these two situations, and possibly%0a* explaining that @@finally@@ blocks can be used in any method, with or without a @@try-catch@@ block.%0a%0a&nbsp;%0a%0a%0a!!Survey Results%0a%0aWritten Explanation categories%0a* Basic:  Simply explains that code in the @@finally@@ block is always executed.  Nothing in the text suggests that placing code in a @@finally@@ block is different that placing it immediately after the last @@catch@@ statement.%0a* Implied: Implies, but doesn't explicitly explain how placing code in a @@finally@@ block differs from placing it after the last @@catch@@ statement.%0a%0aCode Example categories%0a* Unnecessary: @@finally@@ block not necessary.  Putting code after @@catch@@ statements would have the same effect.%0a* Practically unnecessary:@@finally@@ block has a non-trivial effect only in extremely unusual circumstances, such as an @@OutOfMemoryException@@.%0a* Hidden effect:  @@finally@@ block has non-trivial effect, but it is not obvious from the code or accompanying explanation what that is.%0a%0a%0a||!Authors ||!Title ||!ISBN ||!Pages ||!Written Explanation ||!Code Example ||%0a||Anderson and Francheschi [[#AandF|#]] ||Java 6 Illuminated (2e) ||0-7637-4963-X ||737, 747, 791-792  ||Basic ||Practically unnecessary%0a||Lewis, DePasquale, and Chase [[#LPC|#]] ||Java Foundations ||0-321-42972-9 ||441,444 ||Implied ||Practically unnecessary ||%0a||Malik, D.S. [[#Malik1|#]] ||Java Programming|| 1-4188-3540-4 ||747-749 ||Implied ||Hidden effect%0a||Malik, D.S.  [[#Malik2|#]]   ||Java Programming ||0-619-21608 ||775 ||Implied ||Hidden effect ||%0a||Soroka, Barry [[#Soroka|#]] ||Java 5 Objects First ||0-7637-3720-8 ||832-833 ||Explicit ||None ||%0a%0a----%0a[[#AandF]] Anderson and Francheschi. Java 6 Illuminated%0a%0aExplanation (p747):%0a%0a->"Furthermore, after a @@try@@ block and its associated @@catch@@ blocks, you may optionally add a @@finally@@ block, which will always be executed whether an exception occurred or not.  In the @@finally@@ block, you can include some clean-up code.  We will demonstrate a @@finally@@ block when we read from a file later in this chapter."%0a%0aExample (p747):%0a%0a[@%0atry%0a{%0a   // code that might generate an exception%0a}%0acatch( Exception1Class e1 )%0a{         %0a   // code to handle an Exception1Class exception%0a}%0a… %0acatch( ExceptionNClass eN )%0a{%0a   // code to handle an ExceptionNClass exception%0a}  %0afinally%0a{%0a  // code to execute whether or not an exception occurs%0a}%0a@]%0a%0aExample (p790-791):%0a[@%0a1 /* Demonstrating how to read objects from a file%0a2     Anderson, Franceshi%0a3 */%0a4%0a5 import java.io.FileInputStream;%0a6 import java.io.ObjectInputStream;%0a7 import java.io.FileNotFoundException;%0a8 import java.io.EOFException;%0a9 import java.io.IOExceptions;%0a10%0a11 public class ReadingObjects%0a12 {%0a13    public static void maiin( String [ ] args )%0a14    {%0a15      try%0a16      {%0a17          FileInputStream fis = new FileInputStream( “objects “ );%0a18          ObjectInputStream ois = new ObjectInputStream( fis );%0a19%0a20	try%0a21       {%0a22           while ( true )%0a23           {%0a24               // read objects, type cast returned objects to FlightRecord%0a25               FlightRecord2 temp = ( FlightRecord2 ) ois.readObject( );%0a26%0a27               // print the FlightRecord2 object read%0a28               System.out.println( temp );%0a29            }%0a30         } // end inner try block%0a31%0a32          catch ( EOFException eofe )%0a33         {%0a34           System.out.println( “End of the file reached: );%0a35          }%0a36%0a37           catch ( ClassNotFoundException cnfe )%0a38          {%0a39            System.out.println( cnfe.getMessage( ) );%0a40           }%0a41 %0a42            finally%0a43           {%0a44             System.out.println( “closing file” );%0a45             ois.close( );%0a46            }%0a47         } // end outer try block%0a48%0a49          catch ( FileNotFoundException fnfe )%0a50         {%0a51              System.out.println( “Unable to find objects” );%0a52         }%0a53%0a54          catch ( IOException ioe )%0a55         {%0a56                ioe.printStackTrace( );%0a57        }%0a58    }%0a59 }%0a%0a@]%0a%0a----%0a%0a[[#LPC]] John Lewis, Peter DePasquale, and Joseph Chase.  Java Foundations: Introduction to Program Design and Data Structures%0a%0aExplanation (p444):%0a%0a->"A @@try-catch@@ statement can have an optional ''finally clause''.  The @@finally@@ clause defines a section of code that is executed no matter how the @@try@@ block is exited.  Most often, a @@finally@@ clause is used to manage resources or to guarantee that particular parts of an algorithm are executed.%0a%0a->"If no exception is generated, the statements in the @@finally@@ clause are executed after the @@try@@ block is complete.  If an exception is generated in the @@try@@ block, control first transfers to the appropriate @@catch@@ clause.  After executing the exception-handling code, control transfers to the @@finally@@ clause and its statements are executed.  A @@finally@@ clause, if present, must be listed after the @@catch@@ clauses.%0a%0a->"Note that a @@try@@ block does not need to have a @@catch@@ clause at all. If there are no @@catch@@ clauses, a @@finally@@ clause may be used by itself if that is appropriate for the situation."%0a%0aThe phrase "... a section of code that is executed no matter how the @@try@@ block is exited." is good.  However, I believe the next section is misleading: "If an exception is generated in the @@try@@ block, control first transfers to the appropriate @@catch@@ clause.  After executing the exception-handling code, control transfers to the @@finally@@..."  It is too easy for beginning programmers to mistakenly think that the passage makes the following implication:  If the @@try@@ block throws an exception, then one of the @@try@@ block's @@catch@@ statements will handle it.%0a%0aExample (p441):%0a%0a[@%0atry %0a{%0a   System.out.println(Integer.parseInt(numString));%0a} %0acatch (NumberFormatException exception)%0a{%0a   System.out.println("Caught an exceptoin.")%0a}%0afinally%0a{%0a   System.out.println("Done.");%0a}%0a@]%0a%0aIt is not at all clear from this code that the @@try@@ or @@catch@@ block can throw exceptions that aren't caught.%0a%0a%0a%0a----%0a[[#Malik1]]%0aD.S. Malik.  Java Programming:  Program Design Including Data Structures%0a%0aExplanation:  %0a%0a"The last @@catch@@ block may or may not be followed by a @@finally@@ block.  Any code contained in a @@finally@@ block always executes, regardless of whether an exception occurs, except when the program exits early from a @@try@@ block by calling the method @@System.exit@@.  If a @@try@@ block has no @@catch@@ block, then it ''must'' have a @@finally@@ block. ... If there is a @@finally@@ block after the last @@catch@@ block, the @@finally@@ block executes regardless of whether an exception occurs."%0a%0aBecause the @@try@@ block can have a @@finally@@ block without any @@catch@@ blocks, it implies that the @@finally@@ block may be called after uncaught exceptions; but, this is never stated explicitly.%0a%0a%0aExample:%0a%0aBecause the example contains no code, it is not clear what exceptions might be thrown in the @@try@@ block, or what behavior could occur to trigger a non-trivial use of @@finally@@.%0a%0a[@%0atry%0a{%0a   // statements%0a}%0acatch (ExceptionClassName1 objRef1)%0a{%0a   // exception handler code%0a}%0acatch (ExceptionClassName2 objRef2)%0a{%0a  // exception handler code%0a}%0a.%0a.%0a.%0acatch (ExceptionClassNameN objRefN)%0a{%0a   // exception handler code%0a}%0afinally%0a{%0a   // statements%0a}%0a@]%0a%0a%0a%0a----%0a[[#Malik2]]%0aD.S. Malik.  Java Programming: Problem Analysis to Problem Design %0a%0aUses same examples as [[#Malik1|#]]%0a%0a%0a-----%0a%0a[[#Soroka]] Soroka, Barry. Java 5 Objects First%0a%0aExplanation (p832):%0a%0a->"Sometimes we have cod that needs to be done no matter what happens in a @@try@@ block. ... The code in a @@finally@@ block is ''always'' performed.  Even if a statement in a @@try@@ or @@catch@@ block is a @@throw@@, @@return@@, @@break@@, or @@continue@@, the code in the @@finally@@ block is performed before the @@throw@@, @@return@@, @@break@@, or @@continue@@ is executed."%0a%0aThis is one of the better explanations; but, there is no example.%0a%0a%0a
time=1256821036
author:1256821036=
diff:1256821036:1256820985:=115c115%0a%3c ||!Authors ||!Title ||!ISBN ||!Pages ||!Written Explanation ||!Code Example ||%0a---%0a> ||!Authors ||!Title ||!ISBN ||!Pages ||!Written Explanation ||! Code Example ||%0a
host:1256821036=148.61.162.209
author:1256820985=
diff:1256820985:1256820540:=82,85c82,85%0a%3c The fact that the bodies of the blocks are comments implies that the details aren't important.  However, the details are ciritical to the complete understanding of @@finally@@:  If the bodies of these blocks don't have a @@return@@, @@break@@, or @@throws@@ clause, or if no statement in the @@try@@ block throws an uncaught exception, the presence of the @@finally@@ keyword does not affect the behavior of this code.%0a%3c %0a%3c The text accompanying the code above does not clarify this point:%0a%3c %0a---%0a> the fact that the bodies of the blocks are comments implies that the details aren't important.  However, they ''are'':  If the bodies of these blocks don't have a @@return@@, @@break@@, or @@throws@@ clause, or if no statement in the @@try@@ block throws an uncaught exception, the presence of the @@finally@@ keyword does not affect the behavior of this code.%0a> %0a> The accompanying text also does not clarify this point:%0a> %0a88,91c88,91%0a%3c Out of curiosity, I went back through my collection of Java textbooks and categorized both the written explanation of the @@finally@@ keyword and the corresponding sample code.  The remainder of this document contains the results.%0a%3c %0a%3c Avoiding misunderstandings like mine is eays:  Authors should be sure to clearly explain that @@finally@@ blocks are used to guarantee that code gets run even if %0a%3c %0a---%0a> I was curious to see if I just had bad luck with the textbooks I happened to browse, so I went back through my collection and categorized both the written explanation of the @@finally@@ keyword and the provided sample code.  The remainder of this document contains the results.%0a> %0a> The solution to the problem is simple:  Authors should be sure to clearly explain that @@finally@@ blocks are used to guarantee that code gets run even if %0a> %0a95,99c95,96%0a%3c They could further improve the situation by %0a%3c %0a%3c * including sample code that clearly exhibits one of these two situations, and possibly%0a%3c * explaining that @@finally@@ blocks can be used in any method, with or without a @@try-catch@@ block.%0a%3c %0a---%0a> They could further improve the situation by including sample code that clearly exhibits one of these two situations.%0a> %0a115c112%0a%3c ||!Authors ||!Title ||!ISBN ||!Pages ||!Written Explanation ||! Code Example ||%0a---%0a> ||!Authors ||!Title ||!ISBN ||!Pages ||!Written Explanation||! Code Example ||%0a120,121c117,118%0a%3c ||Soroka, Barry [[#Soroka|#]] ||Java 5 Objects First ||0-7637-3720-8 ||832-833 ||Explicit ||None ||%0a%3c %0a---%0a> || Soroka, Barry [[#Soroka|#]] ||Java 5 Objects First ||0-7637-3720-8 ||832-833 ||Explicit ||None ||%0a> %0a223,224c220,221%0a%3c ->"If no exception is generated, the statements in the @@finally@@ clause are executed after the @@try@@ block is complete.  If an exception is generated in the @@try@@ block, control first transfers to the appropriate @@catch@@ clause.  After executing the exception-handling code, control transfers to the @@finally@@ clause and its statements are executed.  A @@finally@@ clause, if present, must be listed after the @@catch@@ clauses.%0a%3c %0a---%0a> ->"If no exception is generated, the statements in the @@finally@@ clause are executed after the @@try@@ block is complete.  If an exception is generated in the @@try@@ block, control first transfers to the appropriate @@catch@@ clause.  After executing the exception-handling code, control transfers to the @@finally@@ clause and its statements are executed.  A @@finally clause, if present, must be listed after the @@catch@@ clauses.%0a> %0a
host:1256820985=148.61.162.209
author:1256820540=
diff:1256820540:1256753700:=1,5c1,5%0a%3c This is kind of embarrassing; but, although I've programmed in Java since 1996 and have taught it since 2004, I just figured out what @@finally@@ blocks are ''really'' for.  When the light bulb finally came on, I went and looked back through several CS 1 and CS 2 texts to see what I missed.  In my opinion, the explanations and examples in these texts are misleading (albeit unintentionally).%0a%3c %0a%3c %0a%3c Consider the two blocks of code below.  From the perspective of a typical CS 1 or CS 2 student, these two code blocks will always have identical behavior. (Note:  The code below is my example, it doesn't represent any book's example.  Those come later.)%0a%3c %0a---%0a> This is kind of embarrassing; but, although I've programmed in Java since 1996 and taught it since 2004, I've just figured out what @@finally@@ blocks are ''really'' for.  When the light bulb finally came on, I went and looked back through several CS 1 and CS 2 texts to see what I missed.  In my opinion, the explanations and examples in these texts are misleading (albeit unintentionally).%0a> %0a> %0a> From the perspective of a typical CS 1 or CS 2 student, there following two blocks of code will always have identical behavior. (Note:  The code below is my example, it doesn't represent any book's example.  Those come later.)%0a> %0a48,53c48,53%0a%3c The circumstances under which the two examples will behave differently are limited to extreme, rare, or advanced situations such as an @@OutOfMemory@@ error or some sort of timer or thread-based interrupt.   Such situations are rare in CS 1 and CS 2.%0a%3c %0a%3c Replacing a @@finally@@ block with a block of code immediately following the @@catch@@ statements only affects the behavior of the code if there is an exit point in one of the @@try@@ or @@catch@@ blocks.  In most textbooks, it is not clear from the example code that such an exit point exists because the @@try@@ and @@catch@@ blocks don't contain any @@return@@, @@break@@, or @@throw@@ statements, and the @@catch@@ blocks appear to catch all possible exceptions (at least from the perspective of a typical CS 1 or CS 2 student).%0a%3c %0a%3c This is precisely why it took me 13 years to figure out what the @@finally@@ block really did:  I had never seen a code example in which it was clear that the method could end without running the code immediately following the last @@catch@@ block.%0a%3c %0a---%0a> The circumstances under which the two examples will behave differently are limited to extreme, rare, or advanced situations such as an @@OutOfMemory@@ error, or some sort of timer or thread-based interrupt.   Such situations are fairly rare in CS 1 and CS 2.%0a> %0a> Replacing a @@finally@@ block with a block of code immediately following the @@catch@@ statements only affects the behavior of the code if there is an exit point in one of the @@try@@ or @@catch@@ blocks.  In most textbooks, it is not clear from the code that such an exit point exists; because the @@try@@ and @@catch@@ blocks don't contain any @@return@@, @@break@@, or @@throw@@ statements, and , from the perspective of a CS 1 or CS 2 student, the @@catch@@ blocks catch all possible exceptions.%0a> %0a> This is precisely why it took me 13 years to figure out what the @@finally@@ block really did:  I had never seen a code example in which it was clear that the method would end without running the code immediately following the last @@catch@@ block.%0a> %0a
host:1256820540=148.61.162.209
author:1256753700=
diff:1256753700:1256753644:=6c6%0a%3c ||!Example 1 ||!Example 2 ||%0a---%0a> ||!Example 1 ||!Example 2||%0a
host:1256753700=148.61.31.131
author:1256753644=
diff:1256753644:1256753581:=112c112%0a%3c ||!Authors ||!Title ||!ISBN ||!Pages ||!Written Explanation||! Code Example ||%0a---%0a> ||!Authors ||!Title ||!ISBN ||!pages ||!Written Explanation||! Code Example ||%0a
host:1256753644=148.61.31.131
author:1256753581=
diff:1256753581:1256674773:=114,118c114,116%0a%3c ||Lewis, DePasquale, and Chase [[#LPC|#]] ||Java Foundations ||0-321-42972-9 ||441,444 ||Implied ||Practically unnecessary ||%0a%3c ||Malik, D.S. [[#Malik1|#]] ||Java Programming|| 1-4188-3540-4 ||747-749 ||Implied ||Hidden effect%0a%3c ||Malik, D.S.  [[#Malik2|#]]   ||Java Programming ||0-619-21608 ||775 ||Implied ||Hidden effect ||%0a%3c || Soroka, Barry [[#Soroka|#]] ||Java 5 Objects First ||0-7637-3720-8 ||832-833 ||Explicit ||None ||%0a%3c %0a---%0a> ||D.S. Malik [[#Malik1|#]] ||Java Programming|| 1-4188-3540-4 ||747-749 ||Implied ||Hidden effect%0a> ||D.S. Malik [[#Malik2|#]]   ||Java Programming ||0-619-21608 ||775 ||Implied|| Hidden effect ||%0a> %0a211a210%0a> %0a213,227c212,225%0a%3c %0a%3c [[#LPC]] John Lewis, Peter DePasquale, and Joseph Chase.  Java Foundations: Introduction to Program Design and Data Structures%0a%3c %0a%3c Explanation (p444):%0a%3c %0a%3c ->"A @@try-catch@@ statement can have an optional ''finally clause''.  The @@finally@@ clause defines a section of code that is executed no matter how the @@try@@ block is exited.  Most often, a @@finally@@ clause is used to manage resources or to guarantee that particular parts of an algorithm are executed.%0a%3c %0a%3c ->"If no exception is generated, the statements in the @@finally@@ clause are executed after the @@try@@ block is complete.  If an exception is generated in the @@try@@ block, control first transfers to the appropriate @@catch@@ clause.  After executing the exception-handling code, control transfers to the @@finally@@ clause and its statements are executed.  A @@finally clause, if present, must be listed after the @@catch@@ clauses.%0a%3c %0a%3c ->"Note that a @@try@@ block does not need to have a @@catch@@ clause at all. If there are no @@catch@@ clauses, a @@finally@@ clause may be used by itself if that is appropriate for the situation."%0a%3c %0a%3c The phrase "... a section of code that is executed no matter how the @@try@@ block is exited." is good.  However, I believe the next section is misleading: "If an exception is generated in the @@try@@ block, control first transfers to the appropriate @@catch@@ clause.  After executing the exception-handling code, control transfers to the @@finally@@..."  It is too easy for beginning programmers to mistakenly think that the passage makes the following implication:  If the @@try@@ block throws an exception, then one of the @@try@@ block's @@catch@@ statements will handle it.%0a%3c %0a%3c Example (p441):%0a%3c %0a---%0a> [[#Malik1]]%0a> D.S. Malik.  Java Programming:  Program Design Including Data Structures%0a> %0a> Explanation:  %0a> %0a> "The last @@catch@@ block may or may not be followed by a @@finally@@ block.  Any code contained in a @@finally@@ block always executes, regardless of whether an exception occurs, except when the program exits early from a @@try@@ block by calling the method @@System.exit@@.  If a @@try@@ block has no @@catch@@ block, then it ''must'' have a @@finally@@ block. ... If there is a @@finally@@ block after the last @@catch@@ block, the @@finally@@ block executes regardless of whether an exception occurs."%0a> %0a> Because the @@try@@ block can have a @@finally@@ block without any @@catch@@ blocks, it implies that the @@finally@@ block may be called after uncaught exceptions; but, this is never stated explicitly.%0a> %0a> %0a> Example:%0a> %0a> Because the example contains no code, it is not clear what exceptions might be thrown in the @@try@@ block, or what behavior could occur to trigger a non-trivial use of @@finally@@.%0a> %0a229c227%0a%3c try %0a---%0a> try%0a231,235c229%0a%3c    System.out.println(Integer.parseInt(numString));%0a%3c } %0a%3c catch (NumberFormatException exception)%0a%3c {%0a%3c    System.out.println("Caught an exceptoin.")%0a---%0a>    // statements%0a237c231%0a%3c finally%0a---%0a> catch (ExceptionClassName1 objRef1)%0a239c233%0a%3c    System.out.println("Done.");%0a---%0a>    // exception handler code%0a240a235,249%0a> catch (ExceptionClassName2 objRef2)%0a> {%0a>   // exception handler code%0a> }%0a> .%0a> .%0a> .%0a> catch (ExceptionClassNameN objRefN)%0a> {%0a>    // exception handler code%0a> }%0a> finally%0a> {%0a>    // statements%0a> }%0a243,246c252,253%0a%3c It is not at all clear from this code that the @@try@@ or @@catch@@ block can throw exceptions that aren't caught.%0a%3c %0a%3c %0a%3c %0a---%0a> %0a> %0a248,290d254%0a%3c [[#Malik1]]%0a%3c D.S. Malik.  Java Programming:  Program Design Including Data Structures%0a%3c %0a%3c Explanation:  %0a%3c %0a%3c "The last @@catch@@ block may or may not be followed by a @@finally@@ block.  Any code contained in a @@finally@@ block always executes, regardless of whether an exception occurs, except when the program exits early from a @@try@@ block by calling the method @@System.exit@@.  If a @@try@@ block has no @@catch@@ block, then it ''must'' have a @@finally@@ block. ... If there is a @@finally@@ block after the last @@catch@@ block, the @@finally@@ block executes regardless of whether an exception occurs."%0a%3c %0a%3c Because the @@try@@ block can have a @@finally@@ block without any @@catch@@ blocks, it implies that the @@finally@@ block may be called after uncaught exceptions; but, this is never stated explicitly.%0a%3c %0a%3c %0a%3c Example:%0a%3c %0a%3c Because the example contains no code, it is not clear what exceptions might be thrown in the @@try@@ block, or what behavior could occur to trigger a non-trivial use of @@finally@@.%0a%3c %0a%3c [@%0a%3c try%0a%3c {%0a%3c    // statements%0a%3c }%0a%3c catch (ExceptionClassName1 objRef1)%0a%3c {%0a%3c    // exception handler code%0a%3c }%0a%3c catch (ExceptionClassName2 objRef2)%0a%3c {%0a%3c   // exception handler code%0a%3c }%0a%3c .%0a%3c .%0a%3c .%0a%3c catch (ExceptionClassNameN objRefN)%0a%3c {%0a%3c    // exception handler code%0a%3c }%0a%3c finally%0a%3c {%0a%3c    // statements%0a%3c }%0a%3c @]%0a%3c %0a%3c %0a%3c %0a%3c ----%0a294,307c258%0a%3c Uses same examples as [[#Malik1|#]]%0a%3c %0a%3c %0a%3c -----%0a%3c %0a%3c [[#Soroka]] Soroka, Barry. Java 5 Objects First%0a%3c %0a%3c Explanation (p832):%0a%3c %0a%3c ->"Sometimes we have cod that needs to be done no matter what happens in a @@try@@ block. ... The code in a @@finally@@ block is ''always'' performed.  Even if a statement in a @@try@@ or @@catch@@ block is a @@throw@@, @@return@@, @@break@@, or @@continue@@, the code in the @@finally@@ block is performed before the @@throw@@, @@return@@, @@break@@, or @@continue@@ is executed."%0a%3c %0a%3c This is one of the better explanations; but, there is no example.%0a%3c %0a%3c %0a---%0a> Uses same examples as [[#Malik1|#]]%0a\ No newline at end of file%0a
host:1256753581=148.61.31.131
author:1256674773=
diff:1256674773:1256674695:=148,207c148%0a%3c 1 /* Demonstrating how to read objects from a file%0a%3c 2     Anderson, Franceshi%0a%3c 3 */%0a%3c 4%0a%3c 5 import java.io.FileInputStream;%0a%3c 6 import java.io.ObjectInputStream;%0a%3c 7 import java.io.FileNotFoundException;%0a%3c 8 import java.io.EOFException;%0a%3c 9 import java.io.IOExceptions;%0a%3c 10%0a%3c 11 public class ReadingObjects%0a%3c 12 {%0a%3c 13    public static void maiin( String [ ] args )%0a%3c 14    {%0a%3c 15      try%0a%3c 16      {%0a%3c 17          FileInputStream fis = new FileInputStream( “objects “ );%0a%3c 18          ObjectInputStream ois = new ObjectInputStream( fis );%0a%3c 19%0a%3c 20	try%0a%3c 21       {%0a%3c 22           while ( true )%0a%3c 23           {%0a%3c 24               // read objects, type cast returned objects to FlightRecord%0a%3c 25               FlightRecord2 temp = ( FlightRecord2 ) ois.readObject( );%0a%3c 26%0a%3c 27               // print the FlightRecord2 object read%0a%3c 28               System.out.println( temp );%0a%3c 29            }%0a%3c 30         } // end inner try block%0a%3c 31%0a%3c 32          catch ( EOFException eofe )%0a%3c 33         {%0a%3c 34           System.out.println( “End of the file reached: );%0a%3c 35          }%0a%3c 36%0a%3c 37           catch ( ClassNotFoundException cnfe )%0a%3c 38          {%0a%3c 39            System.out.println( cnfe.getMessage( ) );%0a%3c 40           }%0a%3c 41 %0a%3c 42            finally%0a%3c 43           {%0a%3c 44             System.out.println( “closing file” );%0a%3c 45             ois.close( );%0a%3c 46            }%0a%3c 47         } // end outer try block%0a%3c 48%0a%3c 49          catch ( FileNotFoundException fnfe )%0a%3c 50         {%0a%3c 51              System.out.println( “Unable to find objects” );%0a%3c 52         }%0a%3c 53%0a%3c 54          catch ( IOException ioe )%0a%3c 55         {%0a%3c 56                ioe.printStackTrace( );%0a%3c 57        }%0a%3c 58    }%0a%3c 59 }%0a%3c %0a---%0a> %0a
host:1256674773=148.61.31.131
author:1256674695=
diff:1256674695:1256673921:=88,101c88,91%0a%3c I was curious to see if I just had bad luck with the textbooks I happened to browse, so I went back through my collection and categorized both the written explanation of the @@finally@@ keyword and the provided sample code.  The remainder of this document contains the results.%0a%3c %0a%3c The solution to the problem is simple:  Authors should be sure to clearly explain that @@finally@@ blocks are used to guarantee that code gets run even if %0a%3c %0a%3c *a @@try@@ block throws an ''unhandled'' exception%0a%3c *a @@try@@ or @@catch@@ block contains a @@return@@ statement%0a%3c %0a%3c They could further improve the situation by including sample code that clearly exhibits one of these two situations.%0a%3c %0a%3c &nbsp;%0a%3c %0a%3c %0a%3c !!Survey Results%0a%3c %0a---%0a> !! Survey%0a> %0a> I was curious to see if I just had bad luck with the textbooks I happened to browse, so I went back through my collection and categorized both the written explanation of the @@finally@@ keyword and the provided sample code.%0a> %0a
host:1256674695=148.61.31.131
author:1256673921=
diff:1256673921:1256673785:=104a105%0a> ||D.S. Malik [[#Malik2|#]]   %0a108,109c109,110%0a%3c [[#AandF]] Anderson and Francheschi. Java 6 Illuminated%0a%3c %0a---%0a> [[#AandF]] Anderson and Francheschi, Java 6 Illuminated%0a> %0a144,145c145,146%0a%3c D.S. Malik.  Java Programming:  Program Design Including Data Structures%0a%3c %0a---%0a> D.S. Malik  Java Programming:  Program Design Including Data Structures%0a> %0a187,188c188,189%0a%3c D.S. Malik.  Java Programming: Problem Analysis to Problem Design %0a%3c %0a---%0a> %0a> %0a
host:1256673921=148.61.31.131
author:1256673785=
diff:1256673785:1256657027:=106,107c106,107%0a%3c ||D.S. Malik [[#Malik2|#]]   ||Java Programming ||0-619-21608 ||775 ||Implied|| Hidden effect ||%0a%3c %0a---%0a> %0a> %0a187,190c187%0a%3c [[#Malik2]]%0a%3c %0a%3c %0a%3c Uses same examples as [[#Malik1|#]]%0a\ No newline at end of file%0a---%0a> [[#Malik2]]%0a\ No newline at end of file%0a
host:1256673785=148.61.31.131
author:1256657027=
diff:1256657027:1256656560:=137,142d136%0a%3c Example (p790-791):%0a%3c [@%0a%3c %0a%3c @]%0a%3c %0a%3c %0a
host:1256657027=148.61.31.131
author:1256656560=
diff:1256656560:1256656368:=93,95c93,95%0a%3c * Basic:  Simply explains that code in the @@finally@@ block is always executed.  Nothing in the text suggests that placing code in a @@finally@@ block is different that placing it immediately after the last @@catch@@ statement.%0a%3c * Implied: Implies, but doesn't explicitly explain how placing code in a @@finally@@ block differs from placing it after the last @@catch@@ statement.%0a%3c %0a---%0a> * Basic:  Simply explains that code in the finally block is always executed.%0a> * Implied: Implies, but doesn't explicitly explain, that there is a difference between placing code in a @@finally@@ block and placing it after the last @@catch@@ statement.%0a> %0a
host:1256656560=148.61.31.131
author:1256656368=
diff:1256656368:1256655906:=111,116d110%0a%3c Explanation (p747):%0a%3c %0a%3c ->"Furthermore, after a @@try@@ block and its associated @@catch@@ blocks, you may optionally add a @@finally@@ block, which will always be executed whether an exception occurred or not.  In the @@finally@@ block, you can include some clean-up code.  We will demonstrate a @@finally@@ block when we read from a file later in this chapter."%0a%3c %0a%3c Example (p747):%0a%3c %0a118c112%0a%3c try%0a---%0a> public class Foo%0a120c114%0a%3c    // code that might generate an exception%0a---%0a>  int hiMom;%0a122,134d115%0a%3c catch( Exception1Class e1 )%0a%3c {         %0a%3c    // code to handle an Exception1Class exception%0a%3c }%0a%3c … %0a%3c catch( ExceptionNClass eN )%0a%3c {%0a%3c    // code to handle an ExceptionNClass exception%0a%3c }  %0a%3c finally%0a%3c {%0a%3c   // code to execute whether or not an exception occurs%0a%3c }%0a
host:1256656368=148.61.31.131
author:1256655906=
diff:1256655906:1256655754:=88,91c88,94%0a%3c !! Survey%0a%3c %0a%3c I was curious to see if I just had bad luck with the textbooks I happened to browse, so I went back through my collection and categorized both the written explanation of the @@finally@@ keyword and the provided sample code.%0a%3c %0a---%0a> %0a> %0a> In my opinion, many CS 1 and CS 2 texts don't properly explain when to use a @@finally@@ block in Java.  Most books say something like "...after a @@try@@ block and and its associated @@catch@@ blocks, you may optionally add a @@finally@@ block, which will always be executed, whether an exception occurred or not." [Anderson and Francheschi]. They then give an example something like this:%0a> %0a> If you look closely, you will notice that the code below will have an identical behavior.%0a> %0a> %0a
host:1256655906=148.61.31.131
author:1256655754=
diff:1256655754:1256655507:=54,55c54,78%0a%3c Consider the following example from Malik's texts:%0a%3c %0a---%0a> %0a> In my opinion, many CS 1 and CS 2 texts don't properly explain when to use a @@finally@@ block in Java.  Most books say something like "...after a @@try@@ block and and its associated @@catch@@ blocks, you may optionally add a @@finally@@ block, which will always be executed, whether an exception occurred or not." [Anderson and Francheschi]. They then give an example something like this:%0a> %0a> If you look closely, you will notice that the code below will have an identical behavior.%0a> %0a> %0a> Written Explanation categories%0a> * Basic:  Simply explains that code in the finally block is always executed.%0a> * Implied: Implies, but doesn't explicitly explain, that there is a difference between placing code in a @@finally@@ block and placing it after the last @@catch@@ statement.%0a> %0a> Code Example categories%0a> * Unnecessary: @@finally@@ block not necessary.  Putting code after @@catch@@ statements would have the same effect.%0a> * Practically unnecessary:@@finally@@ block has a non-trivial effect only in extremely unusual circumstances, such as an @@OutOfMemoryException@@.%0a> * Hidden effect:  @@finally@@ block has non-trivial effect, but it is not obvious from the code or accompanying explanation what that is.%0a> %0a> %0a> ||!Authors ||!Title ||!ISBN ||!pages ||!Written Explanation||! Code Example ||%0a> ||Anderson and Francheschi [[#AandF|#]] ||Java 6 Illuminated (2e) ||0-7637-4963-X ||737, 747, 791-792  ||Basic ||Practically unnecessary%0a> ||D.S. Malik [[#Malik1|#]] ||Java Programming|| 1-4188-3540-4 ||747-749 ||Implied ||Hidden effect%0a> ||D.S. Malik [[#Malik2|#]]   %0a> %0a> %0a> ----%0a> [[#AandF]] Anderson and Francheschi, Java 6 Illuminated%0a> %0a57c80%0a%3c try%0a---%0a> public class Foo%0a59c82%0a%3c    // statements%0a---%0a>  int hiMom;%0a61,79d83%0a%3c catch (ExceptionClassName1 objRef1)%0a%3c {%0a%3c    // exception handler code%0a%3c }%0a%3c catch (ExceptionClassName2 objRef2)%0a%3c {%0a%3c   // exception handler code%0a%3c }%0a%3c .%0a%3c .%0a%3c .%0a%3c catch (ExceptionClassNameN objRefN)%0a%3c {%0a%3c    // exception handler code%0a%3c }%0a%3c finally%0a%3c {%0a%3c    // statements%0a%3c }%0a82,110d85%0a%3c the fact that the bodies of the blocks are comments implies that the details aren't important.  However, they ''are'':  If the bodies of these blocks don't have a @@return@@, @@break@@, or @@throws@@ clause, or if no statement in the @@try@@ block throws an uncaught exception, the presence of the @@finally@@ keyword does not affect the behavior of this code.%0a%3c %0a%3c The accompanying text also does not clarify this point:%0a%3c %0a%3c ->"The last @@catch@@ block may or may not be followed by a @@finally@@ block.  Any code contained in a @@finally@@ block always executes, regardless of whether an exception occurs, except when the program exits early from a @@try@@ block by calling the method @@System.exit@@.  If a @@try@@ block has no @@catch@@ block, then it ''must'' have a @@finally@@ block. ... If there is a @@finally@@ block after the last @@catch@@ block, the @@finally@@ block executes regardless of whether an exception occurs."%0a%3c %0a%3c %0a%3c %0a%3c In my opinion, many CS 1 and CS 2 texts don't properly explain when to use a @@finally@@ block in Java.  Most books say something like "...after a @@try@@ block and and its associated @@catch@@ blocks, you may optionally add a @@finally@@ block, which will always be executed, whether an exception occurred or not." [Anderson and Francheschi]. They then give an example something like this:%0a%3c %0a%3c If you look closely, you will notice that the code below will have an identical behavior.%0a%3c %0a%3c %0a%3c Written Explanation categories%0a%3c * Basic:  Simply explains that code in the finally block is always executed.%0a%3c * Implied: Implies, but doesn't explicitly explain, that there is a difference between placing code in a @@finally@@ block and placing it after the last @@catch@@ statement.%0a%3c %0a%3c Code Example categories%0a%3c * Unnecessary: @@finally@@ block not necessary.  Putting code after @@catch@@ statements would have the same effect.%0a%3c * Practically unnecessary:@@finally@@ block has a non-trivial effect only in extremely unusual circumstances, such as an @@OutOfMemoryException@@.%0a%3c * Hidden effect:  @@finally@@ block has non-trivial effect, but it is not obvious from the code or accompanying explanation what that is.%0a%3c %0a%3c %0a%3c ||!Authors ||!Title ||!ISBN ||!pages ||!Written Explanation||! Code Example ||%0a%3c ||Anderson and Francheschi [[#AandF|#]] ||Java 6 Illuminated (2e) ||0-7637-4963-X ||737, 747, 791-792  ||Basic ||Practically unnecessary%0a%3c ||D.S. Malik [[#Malik1|#]] ||Java Programming|| 1-4188-3540-4 ||747-749 ||Implied ||Hidden effect%0a%3c ||D.S. Malik [[#Malik2|#]]   %0a%3c %0a%3c %0a112,121d86%0a%3c [[#AandF]] Anderson and Francheschi, Java 6 Illuminated%0a%3c %0a%3c [@%0a%3c public class Foo%0a%3c {%0a%3c  int hiMom;%0a%3c }%0a%3c @]%0a%3c %0a%3c ----%0a
host:1256655754=148.61.31.131
author:1256655507=
diff:1256655507:1256655088:=48,54c48,51%0a%3c The circumstances under which the two examples will behave differently are limited to extreme, rare, or advanced situations such as an @@OutOfMemory@@ error, or some sort of timer or thread-based interrupt.   Such situations are fairly rare in CS 1 and CS 2.%0a%3c %0a%3c Replacing a @@finally@@ block with a block of code immediately following the @@catch@@ statements only affects the behavior of the code if there is an exit point in one of the @@try@@ or @@catch@@ blocks.  In most textbooks, it is not clear from the code that such an exit point exists; because the @@try@@ and @@catch@@ blocks don't contain any @@return@@, @@break@@, or @@throw@@ statements, and , from the perspective of a CS 1 or CS 2 student, the @@catch@@ blocks catch all possible exceptions.%0a%3c %0a%3c This is precisely why it took me 13 years to figure out what the @@finally@@ block really did:  I had never seen a code example in which it was clear that the method would end without running the code immediately following the last @@catch@@ block.%0a%3c %0a%3c %0a---%0a> The circumstances under which the two examples will behave differently are not typically found in the context of CS 1 and CS 2.  They include @@OutOfMemory@@ error, or some sort of timer or thread-based interrupt.  %0a> %0a> %0a> %0a
host:1256655507=148.61.31.131
author:1256655088=
diff:1256655088:1256654950:=1,5c1,4%0a%3c This is kind of embarrassing; but, although I've programmed in Java since 1996 and taught it since 2004, I've just figured out what @@finally@@ blocks are ''really'' for.  When the light bulb finally came on, I went and looked back through several CS 1 and CS 2 texts to see what I missed.  In my opinion, the explanations and examples in these texts are misleading (albeit unintentionally).%0a%3c %0a%3c %0a%3c From the perspective of a typical CS 1 or CS 2 student, there following two blocks of code will always have identical behavior. (Note:  The code below is my example, it doesn't represent any book's example.  Those come later.)%0a%3c %0a---%0a> This is kind of embarrassing; but, although I've programmed in Java since 1996 and taught it since 2004, I've just figured out what @@finally@@ blocks are ''really'' for.  It turns out that the explanations and examples in most CS 1 and CS 2 textbooks are (in my opinion) misleading.%0a> %0a> From the perspective of a typical CS 1 or CS 2 student, there following two blocks of code will always have identical behavior%0a> %0a
host:1256655088=148.61.31.131
author:1256654950=
diff:1256654950:1256654527:=47,50c47,50%0a%3c The circumstances under which the two examples will behave differently are not typically found in the context of CS 1 and CS 2.  They include @@OutOfMemory@@ error, or some sort of timer or thread-based interrupt.  %0a%3c %0a%3c %0a%3c %0a---%0a> Although the two examples above can have different behavior, it would require an serious and unusual event such as an @@OutOfMemory@@ error, or some sort of thread-based interruption.  Very few CS 1 or CS 2 students will notice these subtitles. %0a> %0a> %0a> %0a
host:1256654950=148.61.31.131
author:1256654527=
diff:1256654527:1256647525:=1,2c1,2%0a%3c This is kind of embarrassing; but, although I've programmed in Java since 1996 and taught it since 2004, I've just figured out what @@finally@@ blocks are ''really'' for.  It turns out that the explanations and examples in most CS 1 and CS 2 textbooks are (in my opinion) misleading.%0a%3c %0a---%0a> This is kind of embarrassing; but, although I've programmed in Java since 1996 and taught it since 2004, I've just figured out what @@finally@@ blocks are ''really'' for.  It turns out that the explanations and examples in most CS 1 and CS 2 textbooks are unintentionally misleading (in my opinion).%0a> %0a
host:1256654527=148.61.31.131
author:1256647525=
diff:1256647525:1256647257:=8c8%0a%3c    public static int finally1(String data)%0a---%0a>    public static int finallyTest1(String data)%0a10,12d9%0a%3c      if (data == null) {%0a%3c         return 0;%0a%3c      }%0a29,31d25%0a%3c      if (data == null) {%0a%3c         return 0;%0a%3c      }%0a47,50c41,43%0a%3c Although the two examples above can have different behavior, it would require an serious and unusual event such as an @@OutOfMemory@@ error, or some sort of thread-based interruption.  Very few CS 1 or CS 2 students will notice these subtitles. %0a%3c %0a%3c %0a%3c %0a---%0a> %0a> %0a> %0a
host:1256647525=68.188.218.51
author:1256647257=
diff:1256647257:1256647215:=15,16c15,16%0a%3c         err.println(data + %0a%3c                     " is not an integer!");%0a---%0a>         System.err.println(data + %0a>                            " is not an integer!");%0a31c31%0a%3c         err.println(data + %0a---%0a>         System.err.println(data + %0a
host:1256647257=68.188.218.51
author:1256647215=
diff:1256647215:1256647006:=15,16c15%0a%3c         System.err.println(data + %0a%3c                            " is not an integer!");%0a---%0a>         System.err.println(data + " is not an integer!");%0a31,32c30%0a%3c         System.err.println(data + %0a%3c                     " is not an integer!");%0a---%0a>         System.err.println(data + " is not an integer!");%0a
host:1256647215=68.188.218.51
author:1256647006=
diff:1256647006:1256646186:=5,6c5,35%0a%3c ||!Example 1 ||!Example 2||%0a%3c ||[@public class Example 1%0a---%0a> ||[@ Example 1 @] ||[@ Example 2 @] ||%0a> %0a> %0a> %0a> %0a> In my opinion, many CS 1 and CS 2 texts don't properly explain when to use a @@finally@@ block in Java.  Most books say something like "...after a @@try@@ block and and its associated @@catch@@ blocks, you may optionally add a @@finally@@ block, which will always be executed, whether an exception occurred or not." [Anderson and Francheschi]. They then give an example something like this:%0a> %0a> If you look closely, you will notice that the code below will have an identical behavior.%0a> %0a> %0a> Written Explanation categories%0a> * Basic:  Simply explains that code in the finally block is always executed.%0a> * Implied: Implies, but doesn't explicitly explain, that there is a difference between placing code in a @@finally@@ block and placing it after the last @@catch@@ statement.%0a> %0a> Code Example categories%0a> * Unnecessary: @@finally@@ block not necessary.  Putting code after @@catch@@ statements would have the same effect.%0a> * Practically unnecessary:@@finally@@ block has a non-trivial effect only in extremely unusual circumstances, such as an @@OutOfMemoryException@@.%0a> * Hidden effect:  @@finally@@ block has non-trivial effect, but it is not obvious from the code or accompanying explanation what that is.%0a> %0a> %0a> ||!Authors ||!Title ||!ISBN ||!pages ||!Written Explanation||! Code Example ||%0a> ||Anderson and Francheschi [[#AandF|#]] ||Java 6 Illuminated (2e) ||0-7637-4963-X ||737, 747, 791-792  ||Basic ||Practically unnecessary%0a> ||D.S. Malik [[#Malik1|#]] ||Java Programming|| 1-4188-3540-4 ||747-749 ||Implied ||Hidden effect%0a> ||D.S. Malik [[#Malik2|#]]   %0a> %0a> %0a> ----%0a> [[#AandF]] Anderson and Francheschi, Java 6 Illuminated%0a> %0a> [@%0a> public class Foo%0a8,19c37%0a%3c    public static int finallyTest1(String data)%0a%3c    {%0a%3c      int answer;%0a%3c      try {%0a%3c         answer = Integer.parseInt(data);%0a%3c      } catch (NumberFormatException nfe) {%0a%3c         answer = -1;%0a%3c         System.err.println(data + " is not an integer!");%0a%3c      } finally {%0a%3c         System.out.println("Hi, Mom!");%0a%3c      }%0a%3c      return answer; %0a---%0a>  int hiMom;%0a21c39,57%0a%3c @]||[@public class Example 2 %0a---%0a> @]%0a> %0a> ----%0a> [[#Malik1]]%0a> D.S. Malik  Java Programming:  Program Design Including Data Structures%0a> %0a> Explanation:  %0a> %0a> "The last @@catch@@ block may or may not be followed by a @@finally@@ block.  Any code contained in a @@finally@@ block always executes, regardless of whether an exception occurs, except when the program exits early from a @@try@@ block by calling the method @@System.exit@@.  If a @@try@@ block has no @@catch@@ block, then it ''must'' have a @@finally@@ block. ... If there is a @@finally@@ block after the last @@catch@@ block, the @@finally@@ block executes regardless of whether an exception occurs."%0a> %0a> Because the @@try@@ block can have a @@finally@@ block without any @@catch@@ blocks, it implies that the @@finally@@ block may be called after uncaught exceptions; but, this is never stated explicitly.%0a> %0a> %0a> Example:%0a> %0a> Because the example contains no code, it is not clear what exceptions might be thrown in the @@try@@ block, or what behavior could occur to trigger a non-trivial use of @@finally@@.%0a> %0a> [@%0a> try%0a23,35c59%0a%3c    public static int finallyTest1(String data)%0a%3c    {%0a%3c      int answer;%0a%3c      try {%0a%3c         answer = Integer.parseInt(data);%0a%3c      } catch (NumberFormatException nfe) {%0a%3c         answer = -1;%0a%3c         System.err.println(data + " is not an integer!");%0a%3c      } %0a%3c      %0a%3c      System.out.println("Hi, Mom!");%0a%3c      return answer; %0a%3c    }%0a---%0a>    // statements%0a37,67c61%0a%3c @]||%0a%3c %0a%3c %0a%3c %0a%3c %0a%3c In my opinion, many CS 1 and CS 2 texts don't properly explain when to use a @@finally@@ block in Java.  Most books say something like "...after a @@try@@ block and and its associated @@catch@@ blocks, you may optionally add a @@finally@@ block, which will always be executed, whether an exception occurred or not." [Anderson and Francheschi]. They then give an example something like this:%0a%3c %0a%3c If you look closely, you will notice that the code below will have an identical behavior.%0a%3c %0a%3c %0a%3c Written Explanation categories%0a%3c * Basic:  Simply explains that code in the finally block is always executed.%0a%3c * Implied: Implies, but doesn't explicitly explain, that there is a difference between placing code in a @@finally@@ block and placing it after the last @@catch@@ statement.%0a%3c %0a%3c Code Example categories%0a%3c * Unnecessary: @@finally@@ block not necessary.  Putting code after @@catch@@ statements would have the same effect.%0a%3c * Practically unnecessary:@@finally@@ block has a non-trivial effect only in extremely unusual circumstances, such as an @@OutOfMemoryException@@.%0a%3c * Hidden effect:  @@finally@@ block has non-trivial effect, but it is not obvious from the code or accompanying explanation what that is.%0a%3c %0a%3c %0a%3c ||!Authors ||!Title ||!ISBN ||!pages ||!Written Explanation||! Code Example ||%0a%3c ||Anderson and Francheschi [[#AandF|#]] ||Java 6 Illuminated (2e) ||0-7637-4963-X ||737, 747, 791-792  ||Basic ||Practically unnecessary%0a%3c ||D.S. Malik [[#Malik1|#]] ||Java Programming|| 1-4188-3540-4 ||747-749 ||Implied ||Hidden effect%0a%3c ||D.S. Malik [[#Malik2|#]]   %0a%3c %0a%3c %0a%3c ----%0a%3c [[#AandF]] Anderson and Francheschi, Java 6 Illuminated%0a%3c %0a%3c [@%0a%3c public class Foo%0a---%0a> catch (ExceptionClassName1 objRef1)%0a69c63%0a%3c  int hiMom;%0a---%0a>    // exception handler code%0a70a65,79%0a> catch (ExceptionClassName2 objRef2)%0a> {%0a>   // exception handler code%0a> }%0a> .%0a> .%0a> .%0a> catch (ExceptionClassNameN objRefN)%0a> {%0a>    // exception handler code%0a> }%0a> finally%0a> {%0a>    // statements%0a> }%0a72a82,83%0a> %0a> %0a74,116d84%0a%3c [[#Malik1]]%0a%3c D.S. Malik  Java Programming:  Program Design Including Data Structures%0a%3c %0a%3c Explanation:  %0a%3c %0a%3c "The last @@catch@@ block may or may not be followed by a @@finally@@ block.  Any code contained in a @@finally@@ block always executes, regardless of whether an exception occurs, except when the program exits early from a @@try@@ block by calling the method @@System.exit@@.  If a @@try@@ block has no @@catch@@ block, then it ''must'' have a @@finally@@ block. ... If there is a @@finally@@ block after the last @@catch@@ block, the @@finally@@ block executes regardless of whether an exception occurs."%0a%3c %0a%3c Because the @@try@@ block can have a @@finally@@ block without any @@catch@@ blocks, it implies that the @@finally@@ block may be called after uncaught exceptions; but, this is never stated explicitly.%0a%3c %0a%3c %0a%3c Example:%0a%3c %0a%3c Because the example contains no code, it is not clear what exceptions might be thrown in the @@try@@ block, or what behavior could occur to trigger a non-trivial use of @@finally@@.%0a%3c %0a%3c [@%0a%3c try%0a%3c {%0a%3c    // statements%0a%3c }%0a%3c catch (ExceptionClassName1 objRef1)%0a%3c {%0a%3c    // exception handler code%0a%3c }%0a%3c catch (ExceptionClassName2 objRef2)%0a%3c {%0a%3c   // exception handler code%0a%3c }%0a%3c .%0a%3c .%0a%3c .%0a%3c catch (ExceptionClassNameN objRefN)%0a%3c {%0a%3c    // exception handler code%0a%3c }%0a%3c finally%0a%3c {%0a%3c    // statements%0a%3c }%0a%3c @]%0a%3c %0a%3c %0a%3c %0a%3c ----%0a
host:1256647006=68.188.218.51
author:1256646186=
diff:1256646186:1256646169:=5,9c5,9%0a%3c ||[@ Example 1 @] ||[@ Example 2 @] ||%0a%3c %0a%3c %0a%3c %0a%3c %0a---%0a> ||[@ Example 1 @] ||[@ Example 2]] ||%0a> %0a> %0a> %0a> %0a
host:1256646186=148.61.39.203
author:1256646169=
diff:1256646169:1256645877:=3,9c3,5%0a%3c From the perspective of a typical CS 1 or CS 2 student, there following two blocks of code will always have identical behavior%0a%3c %0a%3c ||[@ Example 1 @] ||[@ Example 2]] ||%0a%3c %0a%3c %0a%3c %0a%3c %0a---%0a> %0a> %0a> %0a
host:1256646169=148.61.39.203
author:1256645877=
diff:1256645877:1256602635:=1,5d0%0a%3c This is kind of embarrassing; but, although I've programmed in Java since 1996 and taught it since 2004, I've just figured out what @@finally@@ blocks are ''really'' for.  It turns out that the explanations and examples in most CS 1 and CS 2 textbooks are unintentionally misleading (in my opinion).%0a%3c %0a%3c %0a%3c %0a%3c %0a
host:1256645877=148.61.39.203
author:1256602635=
diff:1256602635:1256593894:=18,21c18,20%0a%3c ||D.S. Malik [[#Malik1|#]] ||Java Programming|| 1-4188-3540-4 ||747-749 ||Implied ||Hidden effect%0a%3c ||D.S. Malik [[#Malik2|#]]   %0a%3c %0a%3c %0a---%0a> ||D.S. Malik [[#Malik1|#]] ||Java Programming|| 1-4188-3540-4 ||747-749 ||Implied ||Hidden effect %0a> %0a> %0a75,76c74%0a%3c ----%0a%3c [[#Malik2]]%0a\ No newline at end of file%0a---%0a> Explanation:%0a
host:1256602635=68.188.218.51
author:1256593894=
diff:1256593894:1256593775:=44,45c44,45%0a%3c Because the example contains no code, it is not clear what exceptions might be thrown in the @@try@@ block, or what behavior could occur to trigger a non-trivial use of @@finally@@.%0a%3c %0a---%0a>  Because the example contains no code, it is not clear what exceptions might be thrown in the @@try@@ block, or what behavior could occur to trigger a non-trivial use of @@finally@@.%0a> %0a
host:1256593894=148.61.39.202
author:1256593775=
diff:1256593775:1256593632:=35,45c35,39%0a%3c Explanation:  %0a%3c %0a%3c "The last @@catch@@ block may or may not be followed by a @@finally@@ block.  Any code contained in a @@finally@@ block always executes, regardless of whether an exception occurs, except when the program exits early from a @@try@@ block by calling the method @@System.exit@@.  If a @@try@@ block has no @@catch@@ block, then it ''must'' have a @@finally@@ block. ... If there is a @@finally@@ block after the last @@catch@@ block, the @@finally@@ block executes regardless of whether an exception occurs."%0a%3c %0a%3c Because the @@try@@ block can have a @@finally@@ block without any @@catch@@ blocks, it implies that the @@finally@@ block may be called after uncaught exceptions; but, this is never stated explicitly.%0a%3c %0a%3c %0a%3c Example:%0a%3c %0a%3c  Because the example contains no code, it is not clear what exceptions might be thrown in the @@try@@ block, or what behavior could occur to trigger a non-trivial use of @@finally@@.%0a%3c %0a---%0a> Explanation:  "The last @@catch@@ block may or may not be followed by a @@finally@@ block.  Any code contained in a @@finally@@ block always executes, regardless of whether an exception occurs, except when the program exits early from a @@try@@ block by calling the method @@System.exit@@.  If a @@try@@ block has no @@catch@@ block, then it ''must'' have a @@finally@@ block. ... If there is a @@finally@@ block after the last @@catch@@ block, the @@finally@@ block executes regardless of whether an exception occurs."%0a> %0a> %0a> Example: Because the example contains no code, it is not clear what exceptions might be thrown in the @@try@@ block, or what behavior could occur to trigger a non-trivial use of @@finally@@.%0a> %0a
host:1256593775=148.61.39.202
author:1256593632=
diff:1256593632:1256593610:=16a17%0a> %0a17a19%0a> %0a
host:1256593632=148.61.39.202
author:1256593610=
diff:1256593610:1256593586:=18,19c18,19%0a%3c ||Anderson and Francheschi [[#AandF|#]] ||Java 6 Illuminated (2e) ||0-7637-4963-X ||737, 747, 791-792  ||Basic ||Practically unnecessary%0a%3c %0a---%0a> ||Anderson and Francheschi [[#AandF]] ||Java 6 Illuminated (2e) ||0-7637-4963-X ||737, 747, 791-792  ||Basic ||Practically unnecessary%0a> %0a
host:1256593610=148.61.39.202
author:1256593586=
diff:1256593586:1256593151:=8,9c8%0a%3c * Implied: Implies, but doesn't explicitly explain, that there is a difference between placing code in a @@finally@@ block and placing it after the last @@catch@@ statement.%0a%3c %0a---%0a> %0a20,22c19,21%0a%3c ||D.S. Malik [[#Malik1|#]] ||Java Programming|| 1-4188-3540-4 ||747-749 ||Implied ||Hidden effect %0a%3c %0a%3c %0a---%0a> ||D.S. Malik [[#Malik1|#]] ||Java Programming|| 1-4188-3540-4 ||747-749 ||%0a> %0a> %0a37,69c36,39%0a%3c Explanation:  "The last @@catch@@ block may or may not be followed by a @@finally@@ block.  Any code contained in a @@finally@@ block always executes, regardless of whether an exception occurs, except when the program exits early from a @@try@@ block by calling the method @@System.exit@@.  If a @@try@@ block has no @@catch@@ block, then it ''must'' have a @@finally@@ block. ... If there is a @@finally@@ block after the last @@catch@@ block, the @@finally@@ block executes regardless of whether an exception occurs."%0a%3c %0a%3c %0a%3c Example: Because the example contains no code, it is not clear what exceptions might be thrown in the @@try@@ block, or what behavior could occur to trigger a non-trivial use of @@finally@@.%0a%3c %0a%3c [@%0a%3c try%0a%3c {%0a%3c    // statements%0a%3c }%0a%3c catch (ExceptionClassName1 objRef1)%0a%3c {%0a%3c    // exception handler code%0a%3c }%0a%3c catch (ExceptionClassName2 objRef2)%0a%3c {%0a%3c   // exception handler code%0a%3c }%0a%3c .%0a%3c .%0a%3c .%0a%3c catch (ExceptionClassNameN objRefN)%0a%3c {%0a%3c    // exception handler code%0a%3c }%0a%3c finally%0a%3c {%0a%3c    // statements%0a%3c }%0a%3c @]%0a%3c %0a%3c %0a%3c %0a---%0a> Explanation:  "The last @@catch@@ block may or may not be followed by a @@finally@@ block.  Any code contained in a @@finally@@ block always executes, regardless of whether an exception occurs, except when the program exits early from a @@try@@ block by calling the method @@System.exit@@.  If a @@try@@ block has no @@catch@@ block, then it ''must'' have a @@finially@@ block."%0a> %0a> %0a> %0a
host:1256593586=148.61.39.202
author:1256593151=
diff:1256593151:1256592635:=16d15%0a%3c %0a19,21d17%0a%3c ||D.S. Malik [[#Malik1|#]] ||Java Programming|| 1-4188-3540-4 ||747-749 ||%0a%3c %0a%3c %0a31,40d26%0a%3c %0a%3c ----%0a%3c [[#Malik1]]%0a%3c D.S. Malik  Java Programming:  Program Design Including Data Structures%0a%3c %0a%3c Explanation:  "The last @@catch@@ block may or may not be followed by a @@finally@@ block.  Any code contained in a @@finally@@ block always executes, regardless of whether an exception occurs, except when the program exits early from a @@try@@ block by calling the method @@System.exit@@.  If a @@try@@ block has no @@catch@@ block, then it ''must'' have a @@finially@@ block."%0a%3c %0a%3c %0a%3c %0a%3c Explanation:%0a
host:1256593151=148.61.39.202
author:1256592635=
diff:1256592635:1256592603:=16,17c16,17%0a%3c ||Anderson and Francheschi [[#AandF]] ||Java 6 Illuminated (2e) ||0-7637-4963-X ||737, 747, 791-792  ||Basic ||Practically unnecessary%0a%3c %0a---%0a> ||Anderson and Francheschi [[#AandF]]|| Java 6 Illuminated (2e) ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary%0a> %0a
host:1256592635=148.61.39.202
author:1256592603=
diff:1256592603:1256592556:=15,17c15,17%0a%3c ||!Authors ||!Title ||!ISBN ||!pages ||!Written Explanation||! Code Example ||%0a%3c ||Anderson and Francheschi [[#AandF]]|| Java 6 Illuminated (2e) ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary%0a%3c %0a---%0a> ||!Authors ||!Title ||!ISBN ||!pages ||!Written Explanation||! Code Example ||Details ||%0a> ||Anderson and Francheschi || Java 6 Illuminated (2e) ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary ||[[#AandF|#]]%0a> %0a
host:1256592603=148.61.39.202
author:1256592556=
diff:1256592556:1256592536:=16,17c16,17%0a%3c ||Anderson and Francheschi || Java 6 Illuminated (2e) ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary ||[[#AandF|#]]%0a%3c %0a---%0a> ||Anderson and Francheschi || Java 6 Illuminated (2e) ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary ||[[#AandF|#]]%0a> %0a
host:1256592556=148.61.39.202
author:1256592536=
diff:1256592536:1256592491:=15,17c15,17%0a%3c ||!Authors ||!Title ||!ISBN ||!pages ||!Written Explanation||! Code Example ||Details ||%0a%3c ||Anderson and Francheschi || Java 6 Illuminated (2e) ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary ||[[#AandF|#]]%0a%3c %0a---%0a> ||!Authors ||!Title ||! Edition ||!ISBN ||!pages ||!Written Explanation||! Code Example ||Details ||%0a> ||Anderson and Francheschi || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary ||[[#AandF|#]]%0a> %0a
host:1256592536=148.61.39.202
author:1256592491=
diff:1256592491:1256592471:=16,17c16,17%0a%3c ||Anderson and Francheschi || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary ||[[#AandF|#]]%0a%3c %0a---%0a> ||Anderson and Francheschi || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary || ||[[#AandF|#]]%0a> %0a
host:1256592491=148.61.39.202
author:1256592471=
diff:1256592471:1256592243:=15,17c15,17%0a%3c ||!Authors ||!Title ||! Edition ||!ISBN ||!pages ||!Written Explanation||! Code Example ||Details ||%0a%3c ||Anderson and Francheschi || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary || ||[[#AandF|#]]%0a%3c %0a---%0a> ||!Authors ||!Title ||! Edition ||!ISBN ||!pages ||!Written Explanation||! Code Example ||%0a> ||[[#AandF | Anderson and Francheschi]] || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary ||%0a> %0a
host:1256592471=148.61.39.202
author:1256592243=
diff:1256592243:1256591950:=16,17c16,17%0a%3c ||[[#AandF | Anderson and Francheschi]] || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary ||%0a%3c %0a---%0a> ||[[#Anderson and Francheschi|!]] || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary ||%0a> %0a19,20c19,20%0a%3c [[#AandF]] Anderson and Francheschi, Java 6 Illuminated%0a%3c %0a---%0a> [[#Anderson and Francheschi]] Anderson and Francheschi, Java 6 Illuminated%0a> %0a
host:1256592243=148.61.39.202
author:1256591950=
diff:1256591950:1256591485:=16,17c16,17%0a%3c ||[[#Anderson and Francheschi|!]] || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic || Practically unnecessary ||%0a%3c %0a---%0a> ||Anderson and Francheschi || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic ||[[#AndersonAndFrancheschi | Practically unnecessary]] ||%0a> %0a19,20c19,20%0a%3c [[#Anderson and Francheschi]] Anderson and Francheschi, Java 6 Illuminated%0a%3c %0a---%0a> [[#AndersonAndFrancheschi]] Anderson and Francheschi, Java 6 Illuminated%0a> %0a
host:1256591950=148.61.39.202
author:1256591485=
diff:1256591485:1256591455:=18c18%0a%3c ----%0a---%0a> %0a
host:1256591485=148.61.39.202
author:1256591455=
diff:1256591455:1256591154:=16,20c16,20%0a%3c ||Anderson and Francheschi || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic ||[[#AndersonAndFrancheschi | Practically unnecessary]] ||%0a%3c %0a%3c %0a%3c [[#AndersonAndFrancheschi]] Anderson and Francheschi, Java 6 Illuminated%0a%3c %0a---%0a> ||Anderson and Francheschi || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic ||Practically unnecessary ||%0a> %0a> %0a> Anderson and Francheschi, Java 6 Illuminated%0a> %0a
host:1256591455=148.61.39.202
author:1256591154=
diff:1256591154:1256590842:=11d10%0a%3c * Practically unnecessary:@@finally@@ block has a non-trivial effect only in extremely unusual circumstances, such as an @@OutOfMemoryException@@.%0a16,26c15%0a%3c ||Anderson and Francheschi || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  ||Basic ||Practically unnecessary ||%0a%3c %0a%3c %0a%3c Anderson and Francheschi, Java 6 Illuminated%0a%3c %0a%3c [@%0a%3c public class Foo%0a%3c {%0a%3c  int hiMom;%0a%3c }%0a%3c @]%0a---%0a> ||Anderson and Francheschi || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  || Basic ||%0a\ No newline at end of file%0a
host:1256591154=148.61.39.202
author:1256590842=
diff:1256590842:1256590204:=1,2c1,2%0a%3c In my opinion, many CS 1 and CS 2 texts don't properly explain when to use a @@finally@@ block in Java.  Most books say something like "...after a @@try@@ block and and its associated @@catch@@ blocks, you may optionally add a @@finally@@ block, which will always be executed, whether an exception occurred or not." [Anderson and Francheschi]. They then give an example something like this:%0a%3c %0a---%0a> In my opinion, many CS 1 and CS 2 texts don't properly explain when to use a "finally" block in Java.  Most books say something like "the code in a finally block always runs."  They then give an example something like this:%0a> %0a6,15c6,9%0a%3c Written Explanation categories%0a%3c * Basic:  Simply explains that code in the finally block is always executed.%0a%3c %0a%3c Code Example categories%0a%3c * Unnecessary: @@finally@@ block not necessary.  Putting code after @@catch@@ statements would have the same effect.%0a%3c * Hidden effect:  @@finally@@ block has non-trivial effect, but it is not obvious from the code or accompanying explanation what that is.%0a%3c %0a%3c %0a%3c ||!Authors ||!Title ||! Edition ||!ISBN ||!pages ||!Written Explanation||! Code Example ||%0a%3c ||Anderson and Francheschi || Java 6 Illuminated ||2 ||0-7637-4963-X ||737, 747, 791-792  || Basic || %0a\ No newline at end of file%0a---%0a> %0a> %0a> %0a> ||!Authors ||!Title ||!ISBN ||!Covers finally||!Written Explanation||! Code Example ||%0a\ No newline at end of file%0a
host:1256590842=148.61.39.202
author:1256590204=
diff:1256590204:1256589986:=0a1%0a> %0a9c10%0a%3c ||!Authors ||!Title ||!ISBN ||!Covers finally||!Written Explanation||! Code Example ||%0a\ No newline at end of file%0a---%0a> |Authors|Title|ISBN|Covers finally|Written Explanation|Code Example|%0a\ No newline at end of file%0a
host:1256590204=148.61.39.202
author:1256589986=
diff:1256589986:1256589732:=1,10c1%0a%3c %0a%3c In my opinion, many CS 1 and CS 2 texts don't properly explain when to use a "finally" block in Java.  Most books say something like "the code in a finally block always runs."  They then give an example something like this:%0a%3c %0a%3c If you look closely, you will notice that the code below will have an identical behavior.%0a%3c %0a%3c %0a%3c %0a%3c %0a%3c %0a%3c |Authors|Title|ISBN|Covers finally|Written Explanation|Code Example|%0a\ No newline at end of file%0a---%0a> It appears that many CS 1 and CS 2 texts don't do good job motivating the use of a finally block in Java.%0a\ No newline at end of file%0a
host:1256589986=148.61.39.202
author:1256589732=
diff:1256589732:1256589732:=1d0%0a%3c It appears that many CS 1 and CS 2 texts don't do good job motivating the use of a finally block in Java.%0a\ No newline at end of file%0a
host:1256589732=148.61.39.202
