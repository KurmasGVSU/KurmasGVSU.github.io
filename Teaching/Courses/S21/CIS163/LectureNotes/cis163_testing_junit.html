
<html lang="en">
<head>
  <title>GVSU School of Computing</title>
  <meta charset="utf-8">
  <style>
    .type-this {
      background-color: #ffddff;
      white-space: nowrap;
    }

    .to-me {
      color: #0000ff;
      font-size: 110%;
    }

    .question, .q {
      color: #cc00cc;
      font-size: 110%;
    }

    .question, .q > ul {
      color: #000000;
      font-size: 91%;
    }

    li p {
      margin: 0;
    }

    .listHeader {
      padding-bottom: 0;
      margin-bottom: 0;
    }

    ul, ol {
      padding-top: 0;
      margin-top: 0;
    }

    table.bottomBorders td {
      border-bottom: 1px solid black;
    }

    .indent25 {
      margin: 25px;
    }

  pre {
    display: inline-block;
    background-color: #f0f0f0;
    padding: 3px;
    padding-right: 10px;
  }

    
    .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .cm {
  color: #999988;
  font-style: italic;
}
.highlight .cp {
  color: #999999;
  font-weight: bold;
}
.highlight .c1 {
  color: #999988;
  font-style: italic;
}
.highlight .cs {
  color: #999999;
  font-weight: bold;
  font-style: italic;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cpf {
  color: #999988;
  font-style: italic;
}
.highlight .err {
  color: #a61717;
  background-color: #e3d2d2;
}
.highlight .gd {
  color: #000000;
  background-color: #ffdddd;
}
.highlight .ge {
  color: #000000;
  font-style: italic;
}
.highlight .gr {
  color: #aa0000;
}
.highlight .gh {
  color: #999999;
}
.highlight .gi {
  color: #000000;
  background-color: #ddffdd;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
  font-weight: bold;
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .gt {
  color: #aa0000;
}
.highlight .kc {
  color: #000000;
  font-weight: bold;
}
.highlight .kd {
  color: #000000;
  font-weight: bold;
}
.highlight .kn {
  color: #000000;
  font-weight: bold;
}
.highlight .kp {
  color: #000000;
  font-weight: bold;
}
.highlight .kr {
  color: #000000;
  font-weight: bold;
}
.highlight .kt {
  color: #445588;
  font-weight: bold;
}
.highlight .k, .highlight .kv {
  color: #000000;
  font-weight: bold;
}
.highlight .mf {
  color: #009999;
}
.highlight .mh {
  color: #009999;
}
.highlight .il {
  color: #009999;
}
.highlight .mi {
  color: #009999;
}
.highlight .mo {
  color: #009999;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #009999;
}
.highlight .sa {
  color: #000000;
  font-weight: bold;
}
.highlight .sb {
  color: #d14;
}
.highlight .sc {
  color: #d14;
}
.highlight .sd {
  color: #d14;
}
.highlight .s2 {
  color: #d14;
}
.highlight .se {
  color: #d14;
}
.highlight .sh {
  color: #d14;
}
.highlight .si {
  color: #d14;
}
.highlight .sx {
  color: #d14;
}
.highlight .sr {
  color: #009926;
}
.highlight .s1 {
  color: #d14;
}
.highlight .ss {
  color: #990073;
}
.highlight .s, .highlight .dl {
  color: #d14;
}
.highlight .na {
  color: #008080;
}
.highlight .bp {
  color: #999999;
}
.highlight .nb {
  color: #0086B3;
}
.highlight .nc {
  color: #445588;
  font-weight: bold;
}
.highlight .no {
  color: #008080;
}
.highlight .nd {
  color: #3c5d5d;
  font-weight: bold;
}
.highlight .ni {
  color: #800080;
}
.highlight .ne {
  color: #990000;
  font-weight: bold;
}
.highlight .nf, .highlight .fm {
  color: #990000;
  font-weight: bold;
}
.highlight .nl {
  color: #990000;
  font-weight: bold;
}
.highlight .nn {
  color: #555555;
}
.highlight .nt {
  color: #000080;
}
.highlight .vc {
  color: #008080;
}
.highlight .vg {
  color: #008080;
}
.highlight .vi {
  color: #008080;
}
.highlight .nv, .highlight .vm {
  color: #008080;
}
.highlight .ow {
  color: #000000;
  font-weight: bold;
}
.highlight .o {
  color: #000000;
  font-weight: bold;
}
.highlight .w {
  color: #bbbbbb;
}
.highlight {
  background-color: #f8f8f8;
}
    
    .highlight {
      display: inline-block;
      background-color: #ffffff;
    }

    pre.highlight {
      background-color: #f0f0f0;
      padding-right: 10px;
    }

  </style>
</head>
<body>
<main id="content">
  <h1 id="testing-and-junit">Testing and JUnit</h1>

<ul>
  <li>Suppose I handed you an Alexa and told you that I taught her to determine leap years.<br />
 Your job is to verify that the skill works correctly.
    <ul>
      <li class="q">What years would you ask her and why?</li>
      <li class="q">How do you decide which years to ask since you can’t ask them all?</li>
    </ul>
  </li>
  <li>These are the skills you need to apply when testing your own software.</li>
  <li>The basic question is “How do I know when my software is correct?”</li>
  <li>You should ask these questions and lay out your test cases <em>before</em> you write any code.  <span class="q">Why?</span>
    <ul>
      <li>It’s foolish to start a project if you have no idea how you’ll know when it’s done.  (How can you even estimate how long it will take?)</li>
      <li>Knowing the test cases in advance reduces the number of times you’ll run into a bug later and have to awkwardly “bolt” it on the side of your existing code.</li>
      <li>The test you write after you write code are often flawed:  When you write tests while looking at completed code, you often incorporate the flaws in the code into your tests, thereby rendering the tests useless.
        <ul>
          <li>In other words, you might unconsciously write tests that will pass the code you wrote, rather than pass the code you should have written.</li>
          <li>For example, if you are looking at code that says <code>for(int x  =
0; x &lt; 100; x++)</code>, you will tend to automatically choose test
cases of 0, 99 and 100, even though the code should have been <code>x &lt;= 100</code>.  If you had written the tests first, you will
be more likely to choose the correct cases.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>This process of writing tests first is called “Test Driven Development” (TDD)
    <ul>
      <li>It’s a good theory, but hard to do in practice.</li>
      <li>It requires discipline and a commitment to code quality.</li>
    </ul>
  </li>
</ul>

<h2 id="types-of-tests">Types of tests</h2>

<ul>
  <li>Two general types of tests:  “White box” and “black box”</li>
  <li>“black box” tests treat the program as a “black box” — one you can’t see into
    <ul>
      <li>You write the tests based solely on the program’s specs.</li>
      <li>In the case of <code>isLeapYear</code>, you would write the tests based solely on the rules for a leap year.</li>
      <li>Key things to consider:
        <ul>
          <li>Normal / typical behavior</li>
          <li>“corner cases” (places where the behavior changes)</li>
          <li>Common error conditions</li>
          <li>Inputs that should never happen but aren’t technically prevented (e.g., negative numbers in the case of <code>isLeapYear</code>)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>“White box” tests are written with the code in mind – you can see into the box.
    <ul>
      <li>Key things to look for
        <ul>
          <li>Values that begin and end a loop.</li>
          <li>Values that trigger either part of an if statement.</li>
          <li>0 values</li>
          <li>null values</li>
          <li>make sure both parts of an if statement are taken</li>
          <li>make sure all the parts of a compound condition (<code>a &amp;&amp; b || c</code>) are tested.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>As mentioned above:  Start with black box tests. White box tests are important; but, bugs in your code can lead to oversights.</li>
  <li>Both tests are important.  Black box tests focus on the rules.  But, when you write the tests, you are implicitly making assumptions about how the code is written.  For example, no (reasonable) amount of black box testing is going to catch a bug like this:  <code>if (year == 1942) {return true}</code>  The white box test is what tells us that we should use 1942 as a test case.</li>
</ul>

<h2 id="junit">JUnit</h2>
<ul>
  <li>In order to make testing practical, it needs to be automated.
    <ul>
      <li>You need to be able to run tests at a push of a button every time you modify the code, otherwise it takes too long, is too boring and doesn’t get done.</li>
      <li>In theory, you should run all your tests after every change.  Even if you “only” touched method <code>x</code> and there is “no way” method <code>y</code> could be affected.  You will be surprised.  Often.  Trust me.</li>
      <li>JUnit <a href="https://junit.org">https://junit.org</a> and TestNG <a href="https://testng.org/">https://testng.org/</a> are the two most popular
        <ul>
          <li>We’ll use JUnit.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Basic idea
    <ul>
      <li>Write a test method that
        <ol>
          <li>Calls the method you are testing</li>
          <li>
            <p>Uses an <code>assert</code> statement to verify you see the expected result.</p>

            <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">isLeapYear</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">assertTrue</span><span class="o">(</span><span class="nc">SimpleDateKurmas</span><span class="o">.</span><span class="na">isLeapYear</span><span class="o">(</span><span class="mi">1956</span><span class="o">));</span>
<span class="o">}</span>
</code></pre></div>            </div>
          </li>
        </ol>
      </li>
      <li>Key points
        <ul>
          <li>method annotated with <code>@Test</code> (allows the magic of “reflection” to identify and run the tests wihtout you having to write code to explicitly call each test)</li>
          <li>method is <code>public void</code></li>
          <li>method takes no parameters (applies to methods annotated with <code>@Test</code>)</li>
          <li><code>assertTrue</code> method is a static provided by JUnit.  The framework keeps track of failures and reports them at the end.</li>
          <li>There are many <code>assert*</code> methods.  <code>assertEquals</code> is probably the most popular. <a href="https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html">https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Suppose you wanted to test the instance method version of <code>isLeapYear</code>.  <span class="q">Write a test for such a method</span></li>
  <li>Now write a test method for the constructor.
    <ul>
      <li class="q">The constructor doesn’t return a value, so what do you assert?</li>
    </ul>
  </li>
  <li>
    <p>Shortcut:  Write one method that can run a test with different values</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nd">@ParameterizedTest</span>
 <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">".isLeapYear recognizes 'regular' years"</span><span class="o">)</span>
 <span class="nd">@ValueSource</span><span class="o">(</span><span class="n">ints</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1997</span><span class="o">,</span> <span class="mi">1998</span><span class="o">,</span> <span class="mi">1999</span> <span class="o">})</span>
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">regularYearStatic</span><span class="o">(</span><span class="kt">int</span> <span class="n">year</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">assertFalse</span><span class="o">(</span><span class="nc">SimpleDateKurmas</span><span class="o">.</span><span class="na">isLeapYear</span><span class="o">(</span><span class="n">year</span><span class="o">),</span> <span class="n">year</span> <span class="o">+</span> <span class="s">" should be a regular year"</span><span class="o">);</span>
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li class="to-me">
    <p>Have everybody open the project in an IDE and make sure the tests compile and run.</p>
  </li>
  <li>The JUnit code (<code>@Test</code>, the <code>assert*</code> methods, etc., etc.) lives in <code>.jar</code> files.
    <ul>
      <li>Your IDE may provide them automatically.</li>
      <li>If not, you can download them from <a href="http://junit.org">http://junit.org</a> and configure them locally.</li>
      <li>For this project, I provide a local copy of <code>junit-platform-console-standalone.jar</code>
        <ul>
          <li>To compile from command line:  <code>java -cp lib/junit-platform-console-standalone.jar <em>java_files</em></code></li>
          <li>To run from command line:<br />
<code>java -jar -cp lib/junit-platform-console-standalone.jar -cp . -c <em>TestClassName</em> </code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="debugging">Debugging</h1>

<ul>
  <li class="to-do">Demonstrate debugging on P1 starter code
    <ul>
      <li>Run the tests.  Notice that <code>constructorWorks</code> fails.</li>
      <li>Set breakpoint on first line of <code>constructorWorks</code> test.</li>
      <li>Add “dummy” <code>new Date163(1, 2, 2003)</code> to avoid class loader.</li>
      <li>Step over the first few lines of code.
        <ul>
          <li>Notice that new variables appear under “Local”</li>
          <li>Notice that you can look inside object.</li>
        </ul>
      </li>
      <li>After stepping over <code>d = new Date163</code>, notice that the instance data are all 0!</li>
      <li>Stop the test. Re-run.  This time, step into.
        <ul>
          <li>Hey:  There’s no code here!</li>
        </ul>
      </li>
      <li>Step into <code>split</code>.</li>
      <li>Show how to step out of.</li>
      <li>Step into constructor.  Show the difference between locals and instance variables</li>
      <li>Change params to <code>lmonth</code>, <code>lday</code>, <code>lyear</code>
        <ul>
          <li>Watch instance variables change.</li>
        </ul>
      </li>
      <li>Show “rename symbol”.  Notice how it changes everywhere.</li>
      <li>Notice test fails now.</li>
      <li>Step through the code to see why
        <ul>
          <li>Instance variables don’t change.</li>
          <li>Local variable is “shadowing” the instance variable.</li>
          <li>Fix:  Use “full name” of instance variable (i.e., prefix with <code>this</code>)
            <ul>
              <li>Show block edit.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Show that you can look back through the stack trace to variables in other frames.</li>
    </ul>
  </li>
</ul>


</main>
</body>
</html>
